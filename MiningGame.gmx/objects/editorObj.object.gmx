<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();



//global.mapGrid = ds_grid_create(4, 4);     //initial grid used to draw tiles
finishedGrid = ds_grid_create(floor(room_width / TILE_SIZE), floor(room_height / TILE_SIZE)); //contains data of rocks and empty space. Used to place objects in level.

mapNumber = 0;
objectList = ds_list_create();      //contains map data of every object
xOffset = 0;
yOffset = 0;        //used to position the tiles in certain places.

//objects + buttons
randomButton = instance_create(view_xview, view_yview + 718, randomizeButtonObj);
templateButton = instance_create(view_xview + 150, view_yview + 718, templateBtnObj);
tierButton = instance_create(view_xview + 300, view_yview + 718, tierBtnObj);
manualButton = instance_create(view_xview + 450, view_yview + 718, manualBtnObj);
player = 0;     //the player instance
exitPortal = 0; //exit instance
ore = 0;        //mineral instance

//states
playerPlaced = false;
exitPlaced = false;
mineralPlaced = false;

 


//get the number of template files
var fileCount = 0;

fileName = file_find_first(working_directory + "*.txt", 0);

while (fileName != "")
{
    fileCount++;
    fileName = file_find_next();
}

show_debug_message("Total templates found: " + string(fileCount));


//start reading the files
var row = 0;
var col = 0;        //iterators for finishedGrid
var colLimit = 4;   //need this in order to access the right grid cells when drawing rocks.

for (var i = 0; i &lt; ds_grid_width(global.mapGrid); i++)
{
    for (var j = 0; j &lt; ds_grid_height(global.mapGrid); j++)
    {
        mapNumber = floor(random_range(1, fileCount + 1));
        var file = "";
        if (mapNumber &lt; 10)
        {
            file = working_directory + "template00" + string(mapNumber) + ".txt";
        }
        else
        {
            file = working_directory + "template0" + string(mapNumber) + ".txt";
        }
        
        if (file_exists(file))
        {
            show_debug_message("Reading " + file);
            var newMap = file_text_open_read(file);
           
            
            //read data from the template
            for (var m = 0; m &lt; MAX_ROWS; m++)
            {
                for (var n = 0; n &lt; MAX_COLS; n++)
                {
                    var tileNum = file_text_read_real(newMap);
                    
                    switch(tileNum)
                    {
                        case 0:
                            ds_grid_set(finishedGrid, col, row, 0);
                            break;
                            
                        case 1:
                            instance_create(n * TILE_SIZE + xOffset, m * TILE_SIZE + yOffset, rockObj)
                            ds_grid_set(finishedGrid, col, row, 1);
                            //ds_list_add(objectList, instance_create(n * TILE_SIZE + xOffset, m * TILE_SIZE + yOffset, rockObj));
                            break;
                                                 
                    }
                    
                    col++;
                    
                }
                
                row++;
                col = colLimit - 4;
            }
                      
            file_text_close(newMap);
           
        }
        
        yOffset += 192; //this is here so tiles are drawn on their own space.
    }
    yOffset = 0;
    row = 0;
    xOffset += 256;
    col = colLimit;
    colLimit += 4;      //limit must be changed so that grid values are written to new cell locations.
}

//next, place the player and exit object in the new grid.
while (!playerPlaced)
{
    var randCol = floor(random_range(0, ds_grid_width(finishedGrid)));
    var randRow = floor(random_range(0, ds_grid_height(finishedGrid)));
    
    if (ds_grid_get(finishedGrid, randCol, randRow) == EMPTY)
    {
        player = instance_create(randCol * TILE_SIZE, randRow * TILE_SIZE, playerObj);
        ds_grid_set(finishedGrid, randCol, randRow, PLAYER_ID);
        playerPlaced = true;
    }
}

while (!exitPlaced)
{
    var randCol = floor(random_range(0, ds_grid_width(finishedGrid)));
    var randRow = floor(random_range(0, ds_grid_height(finishedGrid)));
    var playerTooClose = false;     //if true, exit is too close to player.
    var searchRange = 4;      //used to check the surrounding grid cells for the player.
    
    if (ds_grid_get(finishedGrid, randCol, randRow) == EMPTY &amp;&amp; ds_grid_get(finishedGrid, randCol, randRow) != PLAYER_ID)
    {
        //check if the player is nearby. We don't want the exit to be placed close to the player.
        if (randCol &gt;= searchRange &amp;&amp; randRow &gt;= searchRange)
        {
            var i = randCol - searchRange;
            var j = randRow - searchRange;
            while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange &amp;&amp; i &lt; ds_grid_width(finishedGrid))
            {
                while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange &amp;&amp; j &lt; ds_grid_height(finishedGrid))
                {
                    if (ds_grid_get(finishedGrid, i, j) == PLAYER_ID)
                    {
                        playerTooClose = true;
                    }
                    j++;
                }
                i++;
            }
        }
        else if (randCol &lt; searchRange &amp;&amp; randRow &gt;= searchRange)
        {
            var i = 0;
            var j = randRow - searchRange;
            while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange + 2 &amp;&amp; i &lt; ds_grid_width(finishedGrid))
            {
                while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange &amp;&amp; j &lt; ds_grid_height(finishedGrid))
                {
                    if (ds_grid_get(finishedGrid, i, j) == PLAYER_ID)
                    {
                        playerTooClose = true;
                    }
                    j++;
                }
                i++;
            }
        }
        else if (randCol &gt;= searchRange &amp;&amp; randRow &lt; searchRange)
        {
            var i = randCol - searchRange;
            var j = 0;
            while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange &amp;&amp; i &lt; ds_grid_width(finishedGrid))
            {
                while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange + 2 &amp;&amp; j &lt; ds_grid_height(finishedGrid))
                {
                    if (ds_grid_get(finishedGrid, i, j) == PLAYER_ID)
                    {
                        playerTooClose = true;
                    }
                    j++;
                }
                i++;
            }
        }
        else if (randCol &lt; searchRange &amp;&amp; randRow &lt; searchRange)
        {
            var i = 0;
            var j = 0;
            while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange + 2 &amp;&amp; i &lt; ds_grid_width(finishedGrid))
            {
                while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange + 2 &amp;&amp; j &lt; ds_grid_height(finishedGrid))
                {
                    if (ds_grid_get(finishedGrid, i, j) == PLAYER_ID)
                    {
                        playerTooClose = true;
                    }
                    j++;
                }
                i++;
            }
        }
       
        
        if (!playerTooClose)
        {
            exitPortal = instance_create(randCol * TILE_SIZE, randRow * TILE_SIZE, exitObj);
            ds_grid_set(finishedGrid, randCol, randRow, EXIT_ID);
            exitPlaced = true;
        }
    }
}

while (!mineralPlaced)
{
    var randCol = floor(random_range(0, ds_grid_width(finishedGrid)));
    var randRow = floor(random_range(0, ds_grid_height(finishedGrid)));
    
    if (ds_grid_get(finishedGrid, randCol, randRow) == EMPTY)
    {
        ore = instance_create(randCol * TILE_SIZE, randRow * TILE_SIZE, mineralObj);
        ds_grid_set(finishedGrid, randCol, randRow, 8);
        mineralPlaced = true;
    }
}

//Check if player is too close to exit. If so, then move player to another location.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/** Horizontal movement **/
if (keyboard_check_direct(ord('D')))
{
    if (view_xview + view_wview &lt;= room_width - 8)
        view_xview += 8;
}

if (keyboard_check_direct(ord('A')))
{
    if (view_xview[0] &gt;= 8)
        view_xview[0] -= 8;
}

/** Vertical movement **/
if (keyboard_check_direct(ord('S')))
{
    if (view_yview[0] + view_hview[0] &lt;= room_height - 8)
        view_yview[0] += 8;
}

if (keyboard_check_direct(ord('W')))
{
    if (view_yview[0] &gt;= 8)
        view_yview[0] -= 8;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Update UI positions</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//update UI position
randomButton.x = view_xview;
randomButton.y = view_yview + 718;

templateButton.x = view_xview + 150;
templateButton.y = view_yview + 718;

tierButton.x = view_xview + 300;
tierButton.y = view_yview + 718;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if (ds_exists(mapGrid, ds_type_grid))
{
    show_debug_message("Deleting map grid from memory");
    ds_grid_destroy(mapGrid);
}*/

if (ds_exists(objectList, ds_type_list))
{
    show_debug_message("Deleting object list from memory");
    ds_list_destroy(objectList);
}

if (ds_exists(finishedGrid, ds_type_grid))
{
    show_debug_message("Deleting finished map grid from memory");
    ds_grid_destroy(finishedGrid);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_exists(global.mapGrid, ds_type_grid))
{
    show_debug_message("Deleting map grid from memory");
    ds_grid_destroy(global.mapGrid);
}

if (ds_exists(objectList, ds_type_list))
{
    show_debug_message("Deleting object list from memory");
    ds_list_destroy(objectList);
}

if (ds_exists(finishedGrid, ds_type_grid))
{
    show_debug_message("Deleting finished map grid from memory");
    ds_grid_destroy(finishedGrid);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw grid values
draw_set_font(buttonFont);
//draw_set_colour(c_white);

/*for (var i = 0; i &lt; ds_grid_height(finishedGrid); i++)
{
    for (var j = 0; j &lt; ds_grid_width(finishedGrid); j++)
    {
        draw_text_colour(j * TILE_SIZE + (TILE_SIZE / 2), i * TILE_SIZE + (TILE_SIZE / 2), 
        ds_grid_get(finishedGrid, j, i), c_white, c_white, c_white, c_white, 0.5);
    }
}*/

draw_set_colour(c_white);
draw_text(0, 0, "Tier " + string(global.tier));
draw_text(0, 30, "Map Size: &lt;" + string(room_width) + ", " + string(room_height) + "&gt;");
draw_text(0, 60, "Use WASD to move camera");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
