<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//randomize();
tasks = 0;
totalProgress = 34; //number of frames it takes to load all files.
//check for a quick save file and load its contents instead of creating a new level.
var file = working_directory + "quicksave.ini";
if (file_exists(file))
{
    script_execute(readQuickSaveFile, file);  
    file_delete(file);
}
else
{

    //TODO: This check should be done in the rest area.
    /*if (global.oxygen + 10 &lt;= MAX_OXYGEN)
    {
        global.oxygen += 10;
    }
    else
    {
        global.oxygen = MAX_OXYGEN;
    }*/
    
    //TODO: This check should be done in the rest area.
    /*if (global.tier &lt; MAX_TIER)
    {
        if (global.level % MAX_TIER == 0)
        {
            global.tier++;
        } 
    }*/
    
    //script_execute(resetMods);                  //this should be done in the rest area
    
    bonusStageSet = false;                      //if true, next level is a bonus stage
    mapModSet = false;                          //if true, apply modifier
    
    //states
    playerPlaced = false;
    exitPlaced = false;
    playerTooClose = false;
    global.locationSet = false;     //prevents player from moving when transistioning to next screen
    
        
    /** Check inventory for items, They affect how the map is generated.**/
    if (ds_list_size(global.inventory) &gt; 0)
    {
        var i = 0;
        while (i &lt; ds_list_size(global.inventory))
        {
            switch (ds_list_find_value(global.inventory, i))
            {
                                 
                case ITEMID_REPELLENT:
                    global.repellentEnabled = true;
                    break;
                    
                 case ITEMID_CHARM:
                    global.charmEnabled = true;
                    break;
            }
            i++;
        }
    }
    
    /***Level setup ***/
    
    //check if bonus level is generated
    if (global.level &gt; 1)
    {
        var chance = random(1);
        
        //apply charm bonus if found in inventory. Charm bonus does not stack.
        if (global.charmEnabled)
        {
            var bonusRate = random_range(0.02, 1);
            show_debug_message("Charm applied, bonus rate is " + string(bonusRate * 100) + "%");
            global.bonusRateMod += bonusRate;
        }
        
        show_debug_message("Bonus stage chance is " + string(chance * 100) + "%");
        show_debug_message("Bonus Rate is " + string(global.bonusRateMod * 100) + "%");  
        
        if (chance &lt;= global.bonusRateMod)
        {
            show_debug_message("Bonus Stage created!");
            bonusStageSet = true;
            global.bonusRateMod = 0;
        }
    }
    
    //bonusStageSet = true;
    //generate random map
    if (!bonusStageSet)
    {
        //level modifier?  TODO: As per Dan's suggestion, apply modifier in the rest area so shopkeeper can be used to give hints
        /*var chance = random_range(0, 1);
        show_debug_message("Level mod chance is " + string(chance * 100) + "%");
        show_debug_message("Level mod rate is " + string( * 100) + "%");  
        
        if (global.level &gt; 1 &amp;&amp; chance &lt;= )
        {
            //run a script to generate a mod
            show_debug_message("Level mod created!");
        }*/
        
        //load level.
        var randWidth = floor(random_range(4, 4 + global.tier));   //default is 4
        var randHeight = floor(random_range(4, 4 + global.tier));
        
        ds_grid_resize(global.mapGrid, randWidth, randHeight);
        
        //get the new screen width and height
        var screenWidth = randWidth * MAX_COLS * TILE_SIZE;
        var screenHeight = randHeight * MAX_ROWS * TILE_SIZE;
        
        room_set_width(gameScreen, screenWidth);
        room_set_height(gameScreen, screenHeight);
        
        //set up grids again
        script_execute(resizeGrids, floor(screenWidth / TILE_SIZE), floor(screenHeight / TILE_SIZE));
        
        //get the number of template files
        var fileCount = 0;
        
        fileName = file_find_first(working_directory + "templates\*.txt", 0);
        
        while (fileName != "")
        {
            fileCount++;
            fileName = file_find_next();
        }
        
        show_debug_message("Total templates found: " + string(fileCount));
        
        //start reading the files
        var row = 0;
        var col = 0;        //iterators for finishedGrid
        var colLimit = 4;   //need this in order to access the right grid cells when drawing rocks.
        var xOffset = 0;
        var yOffset = 0;        //used to position the tiles in certain places.
        
        for (var i = 0; i &lt; ds_grid_width(global.mapGrid); i++)
        {
            for (var j = 0; j &lt; ds_grid_height(global.mapGrid); j++)
            {
                var mapNumber = floor(random_range(1, fileCount + 1));
                var file = "";
                if (mapNumber &lt; 10)
                {
                    file = working_directory + "templates\template00" + string(mapNumber) + ".txt";
                }
                else if (mapNumber &lt; 100)
                {
                    file = working_directory + "templates\template0" + string(mapNumber) + ".txt";
                }
                else
                {
                     file = working_directory + "templates\template" + string(mapNumber) + ".txt";
                }
                
                if (file_exists(file))
                {
                    show_debug_message("Reading " + file);
                    var newMap = file_text_open_read(file);
                   
                    
                    //read data from the template
                    for (var m = 0; m &lt; MAX_ROWS; m++)
                    {
                        for (var n = 0; n &lt; MAX_COLS; n++)
                        {
                            var tileNum = file_text_read_real(newMap);
                            
                            switch(tileNum)
                            {
                                case TILE_EMPTY:
                                    ds_grid_set(global.finishedGrid, col, row, 0);
                                    ds_grid_set(global.aStarGrid, col, row, 1);
                                    break;
                                    
                                case TILE_ROCK:
                                    ds_grid_set(global.finishedGrid, col, row, 1);
                                    ds_grid_set(global.aStarGrid, col, row, 0); //avatar will always prefer to dig instead of moving to empty space
                                    global.rockCount++;
                                    break;
                                    
                                case TILE_WALL:
                                    ds_grid_set(global.finishedGrid, col, row, 2);
                                    ds_grid_set(global.aStarGrid, col, row, 8);
                                    break;
                                                         
                            }
                            
                            col++;
                            
                        }
                        
                        row++;
                        col = colLimit - 4;
                    }
                              
                    file_text_close(newMap);
                   
                }
                
                yOffset += 192; //this is here so tiles are drawn on their own space.
            }
            yOffset = 0;
            row = 0;
            xOffset += 256;
            col = colLimit;
            colLimit += 4;      //limit must be changed so that grid values are written to new cell locations.
        }
        
        //next, place the player and exit object in the new grid.
        var playerRow = 0;
        var playerCol = 0;
        while (!playerPlaced)
        {
            var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
            var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
            
            if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
            {
                //player = instance_create(randCol * TILE_SIZE, randRow * TILE_SIZE, playerObj);
                ds_grid_set(global.finishedGrid, randCol, randRow, TILE_PLAYER);
                playerRow = randRow;
                playerCol = randCol;
                playerPlaced = true;
            }
        }
        
        while (!exitPlaced)
        {
            var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
            var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
            
            if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
            {
                ds_grid_set(global.finishedGrid, randCol, randRow, TILE_EXIT);
                exitPlaced = true;
                
                //check if the player is nearby
                var searchRange = 2;
                if (randCol &gt;= searchRange &amp;&amp; randRow &gt;= searchRange)
                {
                    var i = randCol - searchRange;
                    var j = randRow - searchRange;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol &lt; searchRange &amp;&amp; randRow &gt;= searchRange)
                {
                    var i = 0;
                    var j = randRow - searchRange;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + (searchRange * 2) &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol &gt;= searchRange &amp;&amp; randRow &lt; searchRange)
                {
                    var i = randCol - searchRange;
                    var j = 0;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + (searchRange * 2) &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol &lt; searchRange &amp;&amp; randRow &lt; searchRange)
                {
                    var i = 0;
                    var j = 0;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange * 2 &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + (searchRange * 2) &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol == ds_grid_width(global.finishedGrid) - 1 &amp;&amp; randRow &lt; searchRange)
                {
                    var i = ds_grid_width(global.finishedGrid) - (searchRange * 2) - 1;
                    var j = 0;
                    while (!playerTooClose &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + (searchRange * 2) &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol == ds_grid_width(global.finishedGrid) - 1 &amp;&amp; randRow &gt;= searchRange)
                {
                    var i = ds_grid_width(global.finishedGrid) - (searchRange * 2) - 1;
                    var j = randRow - searchRange;
                    while (!playerTooClose &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; randRow + searchRange &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol &lt; searchRange &amp;&amp; randRow == ds_grid_height(global.finishedGrid) - 1)
                {
                    var i = 0;
                    var j = ds_grid_height(global.finishedGrid) - (searchRange * 2) - 1;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + (searchRange * 2) &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
                else if (randCol &gt;= searchRange &amp;&amp; randRow == ds_grid_height(global.finishedGrid) - 1)
                {
                    var i = randCol - searchRange;
                    var j = ds_grid_height(global.finishedGrid) - (searchRange * 2) - 1;
                    while (!playerTooClose &amp;&amp; i &lt; randCol + searchRange &amp;&amp; i &lt; ds_grid_width(global.finishedGrid))
                    {
                        while (!playerTooClose &amp;&amp; j &lt; ds_grid_height(global.finishedGrid))
                        {
                            if (ds_grid_get(global.finishedGrid, i, j) == TILE_PLAYER)
                            {
                                playerTooClose = true;
                                 show_debug_message("Player too close. Moving...");
                            }
                            j++;
                        }
                        i++;
                    }
                }
            }
        }
        
        /*** Add code here to check if player and exit are too close ***/
        var newCol = playerCol;
        var newRow = playerRow;
        while (playerTooClose)
        {
            show_debug_message("Player too close. Moving...");
            ds_grid_set(global.finishedGrid, newCol, newRow, TILE_EMPTY);
             
            newCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
            newRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
            
            //the random values must not be within range of the exit point.
            playerTooClose = script_execute(getPlayerProximity, newCol, newRow, TILE_EXIT);
            
            ds_grid_set(global.finishedGrid, newCol, newRow, TILE_PLAYER);       
        }
        
        
        /****** Add hazards &amp; enemies ******/
        
        if (!global.repellentEnabled)
        {
            //bat. Appears in tier 2 or greater
            if (global.tier &gt; 1)
            {
                var count = 0;
                while (count &lt; global.tier)
                {
                    var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
                    var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
                    
                     if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
                     {
                        ds_grid_set(global.finishedGrid, randCol, randRow, TILE_BAT_NO_ROCK);
                        count++;
                     }
                     else if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_ROCK)
                     {
                        ds_grid_set(global.finishedGrid, randCol, randRow, TILE_BAT_ROCK);
                        count++;
                     } 
                    
                }
            }
        }
        
        
        //tar (only added if tier is 2 or greater)
        if (global.tier &gt; 1)
        {
            var count = 0;
            while (count &lt; global.tier * 3)
            {
                var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
                var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
                
                 if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
                 {
                    ds_grid_set(global.finishedGrid, randCol, randRow, TILE_TAR);
                    count++;
                 }
                
            }
        }
        
        //gas (added if tier is 3 or greater)
        //if (global.tier &gt; 2)
        //{
            var count = 0;
            while (count &lt; global.tier * 3)
            {
                var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
                var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
                
                 if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
                 {
                    ds_grid_set(global.finishedGrid, randCol, randRow, TILE_GAS);
                    count++;
                 }
                
            }
        //}
        
        //rock trap (added if tier is 4 or greater)
        //if (global.tier &gt; 3)
        //{
            var count = 0;
            while (count &lt; global.tier)
            {
                var randCol = floor(random_range(0, ds_grid_width(global.finishedGrid)));
                var randRow = floor(random_range(0, ds_grid_height(global.finishedGrid)));
                
                 if (ds_grid_get(global.finishedGrid, randCol, randRow) == TILE_EMPTY)
                 {
                    ds_grid_set(global.finishedGrid, randCol, randRow, TILE_TRAP);
                    count++;
                 }
                
            }
        //} 
        
        //check for level mod
        script_execute(checkLevelMod, global.modEffect);
    }
    else
    {
        //load a bonus map.  Which map is loaded is random. 
        global.onBonusStage = true;
        
        
        //get the number of bonus maps
        var fileCount = 0;
        
        fileName = file_find_first(working_directory + "bonusmaps\*.txt", 0);
        
        while (fileName != "")
        {
            fileCount++;
            fileName = file_find_next();
        }
        
        show_debug_message("Total bonus maps found: " + string(fileCount));
        
        //choose a random map.
        var mapNumber = floor(random_range(1, fileCount + 1));
        var file = "";
        
        if (mapNumber &lt; 10)
        {
            file = working_directory + "bonusmaps\bonusmap00" + string(mapNumber) + ".txt";
        }
        else if (mapNumber &lt; 100)
        {
            file = working_directory + "bonusmaps\bonusmap0" + string(mapNumber) + ".txt";
        }
        else
        {
             file = working_directory + "bonusmaps\bonusmap" + string(mapNumber) + ".txt";
        }
        
        if (file_exists(file))
        {
            show_debug_message("Reading " + file);
            var newMap = file_text_open_read(file);
            
            //read the map size
            var mapWidth = file_text_read_real(newMap);
            var mapHeight = file_text_read_real(newMap);
            room_set_width(gameScreen, mapWidth);
            room_set_height(gameScreen, mapHeight);
            
            var cols = floor(mapWidth / TILE_SIZE);
            var rows = floor(mapHeight / TILE_SIZE);
            
            //set up grids again
            script_execute(resizeGrids, cols, rows);
            
            for (var i = 0; i &lt; rows; i++)
            {
                for (var j = 0; j &lt; cols; j++)
                {
                    var tile = file_text_read_real(newMap);
                    
                    switch(tile)
                    {
                        case TILE_EMPTY:
                            ds_grid_set(global.finishedGrid, j, i, TILE_EMPTY);
                            //ds_grid_set(global.rockHealthGrid, j, i, 0);
                            break;
                            
                        case TILE_ROCK:
                            ds_grid_set(global.finishedGrid, j, i, TILE_ROCK);
                            //all rocks' HP in the bonusmap is 1.
                            //ds_grid_set(global.rockHealthGrid, j, i, 1);
                            break;
                            
                        case TILE_WALL:
                            ds_grid_set(global.finishedGrid, j, i, TILE_WALL);
                            break;
                            
                        case TILE_PLAYER:
                            ds_grid_set(global.finishedGrid, j, i, TILE_PLAYER);
                            //ds_grid_set(global.rockHealthGrid, j, i, 0);
                            break;
                        
                        case TILE_EXIT:
                            ds_grid_set(global.finishedGrid, j, i, TILE_EXIT);
                            //ds_grid_set(global.rockHealthGrid, j, i, 0);
                            break;
                    }
                }
                file_text_readln(newMap);
            }
            file_text_close(newMap);
        }
         
    }
    
    //life setup
    global.currentMaxHearts = MIN_HEARTS + global.heartLevel - 1;
    
}

global.nextScreen = gameScreen;
instance_create(view_xview, view_yview, screenFadeObj);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//count the number of steps it takes to load everything. This will be used to create a loading bar.
tasks++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>show_debug_message("Steps to load everything: " + string(tasks));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (ds_exists(global.mapGrid, ds_type_grid))
{
    ds_grid_destroy(global.mapGrid);
}

if (ds_exists(global.finishedGrid, ds_type_grid))
{
    ds_grid_destroy(global.finishedGrid);
}

if (ds_exists(global.aStarGrid, ds_type_grid))
{
    ds_grid_destroy(global.aStarGrid);
}

if (ds_exists(global.inventory, ds_type_list))
{
    ds_list_destroy(global.inventory);
}

/*if (ds_exists(global.objectGrid, ds_type_grid))
{
    ds_grid_destroy(global.objectGrid);
}*/

if (ds_exists(global.inventory, ds_type_list))
{
    ds_list_destroy(global.inventory);
}

if (part_system_exists(global.particleSystem))
{
    part_system_destroy(global.particleSystem);
}

if (part_type_exists(global.dirtPart))
{
    part_type_destroy(global.dirtPart);
}

if (part_type_exists(global.sparkPart))
{
    part_type_destroy(global.sparkPart);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(gameScreenFont);
draw_set_colour(c_white);
draw_text(view_wview / 2, view_hview - 50, "Loading..." + string(floor(tasks / totalProgress * 100)) + "%");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
